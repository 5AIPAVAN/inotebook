// VID-43

# no need to commit nodemodules to github
# maintain different files to keep folder well organized and clear
# install nodemon as devDependency
# to run --> nodemon .\index.js
# server automatically restarts once u save the code
# check thunderclient with http://localhost:3000 to get response 'hello world'(not https)


// VID-44

# maintain a good file structure for good organization (all schemas in `modules` folder  ,all routes in `routes` folder)
# MongoDB -> Database -> Collection -> documents(.json data)
# create models folder to store all schemas
# create routes folder to store all routes


//VID-45

# UPDATE:- use this const mongoose = require('mongoose'); instead of import mongoose from 'mongoose' in model files
# in thunder client set headers -> Content-type as application/json
# to use req.body(in route files) we need to include a middle-ware 'app.use(express.json())' in index.js file
# just use localhost:3000/api/auth in thunder clients(remove http:// etc)
# in this video users are created using 
#  const user = User(req.body);
    user.save();
# later in next video method to create is changed

# GET method works fine here but , internally in system logs it may show your password(not shown when using POST)
# need to use POST method instead of GET
# for using post first change router.get to router.post and later change method to post in thunder client
# will see validations in next video

// VID-46

# install express-validator --> npm install express-validator
# include const { query, validationResult } = require('express-validator'); in route files(destructuring)
# validations are written in an array between route path and callback function in router methods
  i.e :-  router.post('/', (req, res) => {callback function})
       to add validations
       router.post('/',[ ADD VALIDATIONDS HERE ], (req, res) => {callback function})

# must include const { body, validationResult } = require('express-validator'); in route files 
  for writing validations (express validator website)    

# example of adding a validation

    body('name').isLength({ min: 3 }),
    body('email').isEmail()

# can add custom error message to validations

    body('name','ENTER A VALID NAME').isLength({ min: 3 }),
    body('email','ENTER A VALID EMAIL').isEmail()

# TO CHECK ERRORS IN VALIDATIONS (FOR CODE TO CONTINUE ITS EXECUTION)

# NOTE :- const errors = validationResult(req); // USE req NOT req.body HERE

// if any errors -> this block is executed and errors are displayed in terminal
 const errors = validationResult(req);
    if (!errors.isEmpty()) {
      return res.status(400).json({errors:errors.array()});
    }

# UPDATED METHOD CREATING AN INSTANCE IN MONGODB 

    User.create({
        name:req.body.name,
        email:req.body.email,
        password:req.body.password
    }).then((user)=>{res.json(user)}) // if no errors - then executes
    .catch((err)=>{console.log(err)   // if errors - catch block executed
             res.json({error:'PLEASE ENTER A UNIQUE VALUE FOR EMAIL',message:err.message})})


# TO AVOID DUPLICATE INSTANCES(*********) 

const User = mongoose.model('user_schema',UserSchema);
User.createIndexes(); // IMP:- CREATED w.r.t email as it is declared {unique:true}
module.exports = User;


//VID-47

#  User.createIndexes(); // TO AVOID DUPLICATE ENTRIES - based on unique key in schema i.e:- email here
# *** NO NEED OF CREATING INDEXES WHEN U ARE CHECKING(WHETHER IT IS ALREADY PRESENT) FROM DATABASE AND ADDING NEW

# MAKING CALL BACK FUNCTIONS(i.e:- (req,res)) -> async,await

# *** dont forget to use async,await in time taking functions

# no need to use .then,.catch when we are using async,await

# need to use flower brackets inside curved brackets when sending in json format
  i.e: res.status(400).json({error:"Some error occured"});

# create new collection -> folder(iNotebook)->  folder Authentication -> requests

# create new request -> create new user (USING POST method)

***** USE TRY-CATCH (after checking errors part)******(ERROR HANDLING)


//VID-48 

# LISTEN ABOUT SALT PEPPER HASHING PASSWORDS


//VID-49

# using bcryptjs
# install bcryptjs -> npm install bcryptjs

# GENERATE SALT USING :- const salt =  await bcrypt.genSaltSync(10);

# HASH NEW USER PASSWORD :- const encoded_password = await bcrypt.hashSync(req.body.password, salt);

# ************ JWT **************

# used to verify a user

# sign is important part of jwt token( you need to create a secret key -> use this key to sign jwt token)

# jwt - for secure communication between client and server

# document retrievel is fast when we use obi_id in mongodb for retievel than other attributes

# here user id is used as data (not clear for what)



// VID-50

# Untill now we have seet that -> when ever a new user is registered he gets an auth-token(jwt token)

# now we are going to create end point for -> user login

# bcrypt.compare(password,found_user.password)
 -> password  -> text form
 -> found_user.password -> hashed form

 bcrypt.compare -> internally performs some functions and compared these two passwords
 -> return true or false 

 # password security is good when using POST method than others (GET)

 # using await is compulsory


 // VID-51

# EXTRACTING LOGGED-IN USER DETAILS FROM his/her JWT-token using middleware -> fetchuser

# we are sending id when we are creating jwt token (see code below)
      const DATA = {
            found_user: {
                id: found_user.id
            }
        }
        const JWT_SECRET_KEY = "$@IPAVAN";
        const jwt_data = await jwt.sign(DATA, JWT_SECRET_KEY);

# THAT MEANS jwt token contains user id -> We Need To Extract it 

# here we use a middleware function to get user data from given jwt token (given-auth-token here)

# MIDDLEWARE functions : - just write functions in this folder and use where ever u want
                           instead of repeating whole code -> just call middleware function

# router.post('/getuser', fetchuser , async (req, res) => {.......}) 
  -> code runs in order -> /getuser -> fetchuser middleware ->async (req, res) => {.......}

# ReferenceError: body is not defined -> error because of not includeing express-validator in file
  i.e :- const { body, validationResult } = require('express-validator');

  
  
// VID-52

# every note in notedatabase is associated with particular user (owner of note)
# we need to use a foreign key like attribute in note schema to achieve this(associating with owner user)
# find all notes of particular user and print them
# adding new note 


// VID-53,54

# Users cannot update or delete other users notes-> check user of nodes before updating or deleting


  if(note.user.toString() !== req.user.id ){
            return res.status(401).json({ error: "Changing others notes !!! .. NOT ALLOWED !!!!" })
        }

if(note.user.toString() !== req.user.id ){
            return res.status(401).json({ error: "Deleting others notes !!! .. NOT ALLOWED !!!!" })
        }


// VID-55

# concurrently can be installed in porject folder to start both frondend and backend at a time
   npm i concurrently

# add a new script in package.json using concurrently 

 - "project":"concurrently \"npm run start\" \"nodemon backend/index.js\""

# npm run project is new command to start both frontend and backend

// VID-57

# understanding contextApI


// VID-58

# USING CONTEXT API 
# In noteState.js ,write all variables,functions here in value={{  }} to use them further
# **  value={{  }}  must use two flower brackets as it is sent as object....

// VID-59

# useLocation() hook of react-router-dom
# usually used in navbar component as it contains all routes
# This hook returns the current location object.
 This can be useful if you'd like to perform some side effect whenever the current location changes. 
# location.pathname can be used to print current path .... etc
# here we used to highlight active path in navbar according to present path...
ex:-  <Link className={`nav-link ${location.pathname==="/about" ? "active" : ""}`} to="/about">About</Link>

// VID-60

# entering notes manually(instead of fetching from API) in noteState.js for fetching notes in home.js

# using .map to print each note from (imported)notes array in home.js 

i.e:-  {notes.map((note)=>{
            return note.title
            })}


//VID-61

// once read about col-md-4 , col-md-3 classes in bootstrap -> how it divides screen size to components

// create NoteItem component for each note..

// All Notes are printed in Home.js in second half (Notes.js component)

             {notes.map((note) => {
                    return <NoteItem note={note} />
                })}

# for each note in notes array -> details are printed in card i.e NoteItem component

// VID-62

# include <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.1/font/bootstrap-icons.css">
  in head tag of index.html and use bootstrap icons

# learn bootstrap class aboout display flex , justify content , align items

// VID-63

# Home.js component contains two sub components -> AddNote.js(upper),Notes.js(lower)
# Adding new note in client side (just front-end)-> adding new object(newnote) into array of objects(notes)
# no backend API connection
# writing new function addNote in noteState.js
# import noteContext in AddNote.js component to use addNote function written in noteState.js
# know about   e.preventDefault(); in handleClick in AddNote.js component
# ***** know about :-
   const onnnChange =(e)=>{
         setNote({...note,[e.target.name]:e.target.value});
    }
# using addNote(note.title,note.description,note.tag); in AddNote.js to add new note in noteState.js
# this is all done in just frontend -> nothing updates in database

# SetNotes(notes.concat(newNote)); insted of SerNotes(notes.push(newNote))
 -> concat returns an array ,where push updates an array

// VID-64

# adding deleteNote function in noteState.js

# const filteredNotes =  notes.filter((note)=>{return (note._id !== id)});
 -> removes note with given id from notes array(array if objects notes)

#